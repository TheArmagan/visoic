[RenderContext] Fragment shader code:

struct Uniforms {
  time: f32,
  timeDelta: f32,
  renderSize: vec2<f32>,
  passIndex: f32,
  frameIndex: f32,
  layerOpacity: f32,
  speed: f32,
  date: vec4<f32>,
  opacity: f32,
  forceAlpha: f32,
  blendModeA: f32,
  blendModeB: f32,
  blendModeProgress: f32,
  BUILTIN_SPEED: f32,
};


@group(0) @binding(0) var<uniform> uniforms: Uniforms;
@group(0) @binding(1) var baseTexture: texture_2d<f32>;
@group(0) @binding(2) var baseTextureSampler: sampler;
@group(0) @binding(3) var layerTexture: texture_2d<f32>;
@group(0) @binding(4) var layerTextureSampler: sampler;



// Vertex output structure (must match vertex shader)
struct VertexOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) uv: vec2<f32>,
};

// Helper functions
fn TIME() -> f32 { return uniforms.time; }
fn TIMEDELTA() -> f32 { return uniforms.timeDelta; }
fn RENDERSIZE() -> vec2<f32> { return uniforms.renderSize; }
fn PASSINDEX() -> i32 { return i32(uniforms.passIndex); }
fn FRAMEINDEX() -> i32 { return i32(uniforms.frameIndex); }
fn DATE() -> vec4<f32> { return uniforms.date; }
fn SPEED() -> f32 { return uniforms.speed; }

fn PASSINDEX_F32() -> f32 { return uniforms.passIndex; }
fn FRAMEINDEX_F32() -> f32 { return uniforms.frameIndex; }

// ISF coordinate helpers
fn isf_FragNormCoord(uv: vec2<f32>) -> vec2<f32> {
  return uv;
}

fn isf_FragCoord(uv: vec2<f32>) -> vec2<f32> {
  return uv * uniforms.renderSize;
}

// Texture sampling helpers
// Use textureSampleLevel with LOD 0 to allow sampling in non-uniform control flow (if statements)
fn IMG_NORM_PIXEL(tex: texture_2d<f32>, samp: sampler, coord: vec2<f32>) -> vec4<f32> {
  return textureSampleLevel(tex, samp, coord, 0.0);
}

fn IMG_PIXEL(tex: texture_2d<f32>, samp: sampler, coord: vec2<f32>) -> vec4<f32> {
  return textureSampleLevel(tex, samp, coord / uniforms.renderSize, 0.0);
}

fn IMG_THIS_PIXEL(tex: texture_2d<f32>, samp: sampler, uv: vec2<f32>) -> vec4<f32> {
  return textureSampleLevel(tex, samp, uv, 0.0);
}

// GLSL compatibility
fn mix_f32(a: f32, b: f32, t: f32) -> f32 { return a * (1.0 - t) + b * t; }
fn mix_vec2(a: vec2<f32>, b: vec2<f32>, t: f32) -> vec2<f32> { return a * (1.0 - t) + b * t; }
fn mix_vec3(a: vec3<f32>, b: vec3<f32>, t: f32) -> vec3<f32> { return a * (1.0 - t) + b * t; }
fn mix_vec4(a: vec4<f32>, b: vec4<f32>, t: f32) -> vec4<f32> { return a * (1.0 - t) + b * t; }


fn fract_f32(x: f32) -> f32 { return x - floor(x); }
fn fract_vec2(x: vec2<f32>) -> vec2<f32> { return x - floor(x); }
fn fract_vec3(x: vec3<f32>) -> vec3<f32> { return x - floor(x); }
fn fract_vec4(x: vec4<f32>) -> vec4<f32> { return x - floor(x); }

fn mod_f32(x: f32, y: f32) -> f32 { return x - y * floor(x / y); }
fn mod_vec2(x: vec2<f32>, y: f32) -> vec2<f32> { return x - y * floor(x / y); }
fn mod_vec3(x: vec3<f32>, y: f32) -> vec3<f32> { return x - y * floor(x / y); }
fn mod_vec4(x: vec4<f32>, y: f32) -> vec4<f32> { return x - y * floor(x / y); }

// NOTE: WGSL reserves mod as a keyword and does not support function overloading.
// We rewrite GLSL mod(a,b) calls into a - b * floor(a / b) in the converter.

// (removed #define PI ...)
// (removed #define EPSILON ...)

fn HueToRGB(f1_in: f32, f2_in: f32, hue_in: f32) -> f32 {
  var f1: f32 = f1_in;
  var f2: f32 = f2_in;
  var hue: f32 = hue_in;
  if (hue < 0.0) {
    hue += 1.0;
  }
  else if (hue > 1.0) {
    hue -= 1.0;
  }
  var res: f32;
  if ((6.0 * hue) < 1.0) {
    res = f1 + (f2 - f1) * 6.0 * hue;
  }
  else if ((2.0 * hue) < 1.0) {
    res = f2;
  }
  else if ((3.0 * hue) < 2.0) {
    res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;
  }
  else {
    res = f1;
  }

  return res;
}

fn HSLToRGB(hsl_in: vec3<f32>) -> vec3<f32> {
  var hsl: vec3<f32> = hsl_in;
  var rgb: vec3<f32>;
  
  if (hsl.y == 0.0) {
    rgb = vec3<f32>(hsl.z); // Luminance
  }
  else {
    var f2: f32;
    
    if (hsl.z < 0.5) {
      f2 = hsl.z * (1.0 + hsl.y);
    }
    else {
      f2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);
    }
      
    var f1: f32 = 2.0 * hsl.z - f2;
    
    rgb.r = HueToRGB(f1, f2, hsl.x + (1.0/3.0));
    rgb.g = HueToRGB(f1, f2, hsl.x);
    rgb.b= HueToRGB(f1, f2, hsl.x - (1.0/3.0));
  }
  
  return rgb;
}

fn RGBToHSL(color_in: vec3<f32>) -> vec3<f32> {
  var color: vec3<f32> = color_in;
  var hsl: vec3<f32>;

  var fmin: f32 = min(min(color.r, color.g), color.b);  // Min. value of RGB
  var fmax: f32 = max(max(color.r, color.g), color.b);  // Max. value of RGB
  var delta: f32 = fmax - fmin;                         // Delta RGB value

  hsl.z = (fmax + fmin) / 2.0; // Luminance

  // no chroma
  if (delta == 0.0)	{
    hsl.x = 0.0;	// Hue
    hsl.y = 0.0;	// Saturation
  }
  // chroma
  else {
    if (hsl.z < 0.5) {
      hsl.y = delta / (fmax + fmin); // Saturation
    }
    else {
      hsl.y = delta / (2.0 - fmax - fmin); // Saturation
    }
    
    var deltaR: f32 = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;
    var deltaG: f32 = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;
    var deltaB: f32 = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;

    if (color.r == fmax ) {
      hsl.x = deltaB - deltaG; // Hue
    }
    else if (color.g == fmax) {
      hsl.x = (1.0 / 3.0) + deltaR - deltaB; // Hue
    }
    else if (color.b == fmax) {
      hsl.x = (2.0 / 3.0) + deltaG - deltaR; // Hue
    }
    if (hsl.x < 0.0) {
      hsl.x += 1.0; // Hue
    }
    else if (hsl.x > 1.0) {
      hsl.x -= 1.0; // Hue
    }
  }

  return hsl;
}

fn permute(x_in: vec3<f32>) -> vec3<f32> {
  var x: vec3<f32> = x_in; 
  return (((((x*34.0)+1.0)*x) - (289.0) * floor((((x*34.0)+1.0)*x) / (289.0)))); 
}

fn simplex2DNoise(v_in: vec2<f32>) -> f32 {
  var v: vec2<f32> = v_in;
  const C: vec4<f32> = vec4<f32>(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
  var i: vec2<f32> = floor(v + dot(v, C.yy) );
  var x0: vec2<f32> = v - i + dot(i, C.xx);
  var i1: vec2<f32>;
  i1 =select(vec2<f32>(0.0, 1.0), vec2<f32>(1.0, 0.0), (x0.x > x0.y));
  var x12: vec4<f32> = x0.xyxy + C.xxzz;
  x12 = vec4<f32>(x12.xy - (i1), x12.z, x12.w);
  i = (((i) - (289.0) * floor((i) / (289.0))));
  var p: vec3<f32> = permute(permute( i.y + vec3<f32>(0.0, i1.y, 1.0 )) + i.x + vec3<f32>(0.0, i1.x, 1.0 ));
  var m: vec3<f32> = max(0.5 - vec3<f32>(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), vec3<f32>(0.0));
  m = m*m ;
  m = m*m ;
  var x: vec3<f32> = 2.0 * fract(p * C.www) - 1.0;
  var h: vec3<f32> = abs(x) - 0.5;
  var ox: vec3<f32> = floor(x + 0.5);
  var a0: vec3<f32> = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
  var g: vec3<f32>;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  { let _sw = a0.yz * x12.xz + h.yz * x12.yw; g.y = _sw.x; g.z = _sw.y; }
  return 130.0 * dot(m, g);
}


fn blend(sourceColor_in: vec4<f32>, destinationColor_in: vec4<f32>, blendMode_in: i32, blendOpacity_in: f32, uv: vec2<f32>) -> vec4<f32>  {
  var sourceColor: vec4<f32> = sourceColor_in;
  var destinationColor: vec4<f32> = destinationColor_in;
  var blendMode: i32 = blendMode_in;
  var blendOpacity: f32 = blendOpacity_in;
  var sourceRGB: vec3<f32> = sourceColor.rgb;
  var destinationRGB: vec3<f32> = destinationColor.rgb;
  
  var sourceA: f32 = sourceColor.a;
  var destinationA: f32 = destinationColor.a;

  var blendedColor: vec4<f32>;

  // Normal
  if (blendMode == 0) {
    blendedColor = vec4<f32>(sourceRGB, blendedColor.a);
  }

  // Add 
  else if (blendMode == 1) {
    blendedColor = vec4<f32>(sourceRGB + destinationRGB, blendedColor.a);
  }

  // Subtract
  else if (blendMode == 2) {
    blendedColor = vec4<f32>(destinationRGB - sourceRGB, blendedColor.a);
  }

  // Multiply
  else if (blendMode == 3) {
    blendedColor = vec4<f32>(sourceRGB * destinationRGB, blendedColor.a);
  }

  // Darken
  else if (blendMode == 4) {
    blendedColor = vec4<f32>(min(sourceRGB, destinationRGB), blendedColor.a);
  }

  // Color Burn
  else if (blendMode == 5) {
    blendedColor = vec4<f32>(vec3<f32>(select((1.0 - ((1.0 - destinationRGB.r) / sourceRGB.r)), 0.0, (sourceRGB.r == 0.0)),select((1.0 - ((1.0 - destinationRGB.g) / sourceRGB.g)), 0.0, (sourceRGB.g == 0.0)),select((1.0 - ((1.0 - destinationRGB.b) / sourceRGB.b)), 0.0, (sourceRGB.b == 0.0))), blendedColor.a);
  }

  // Linear Burn
  else if (blendMode == 6) {
    blendedColor = vec4<f32>(sourceRGB + destinationRGB - 1.0, blendedColor.a);
    blendedColor = vec4<f32>(clamp(blendedColor.rgb, vec3<f32>(0.0), vec3<f32>(1.0)), blendedColor.a);
  }

  // Lighten
  else if (blendMode == 7) {
    blendedColor = vec4<f32>(max(sourceRGB, destinationRGB), blendedColor.a);
  }

  // Screen  
  else if (blendMode == 8) {
    blendedColor = vec4<f32>(sourceRGB + destinationRGB - sourceRGB * destinationRGB, blendedColor.a);
  }

  // Color Dodge
  else if (blendMode == 9) {
    blendedColor = vec4<f32>(vec3<f32>(select(min(1.0, destinationRGB.r / (1.0 - sourceRGB.r)), 1.0, (sourceRGB.r == 1.0)),select(min(1.0, destinationRGB.g / (1.0 - sourceRGB.g)), 1.0, (sourceRGB.g == 1.0)),select(min(1.0, destinationRGB.b / (1.0 - sourceRGB.b)), 1.0, (sourceRGB.b == 1.0))), blendedColor.a);
  }  

  // Linear Dodge
  else if (blendMode == 10) {
    blendedColor = vec4<f32>(sourceRGB + destinationRGB, blendedColor.a);
  }

  // Overlay
  else if (blendMode == 11) {
    blendedColor = vec4<f32>(vec3<f32>(select((1.0 - 2.0 * (1.0 - destinationRGB.r) * (1.0 - sourceRGB.r)), (2.0 * sourceRGB.r * destinationRGB.r), (destinationRGB.r <= 0.5)),select((1.0 - 2.0 * (1.0 - destinationRGB.g) * (1.0 - sourceRGB.g)), (2.0 * sourceRGB.g * destinationRGB.g), (destinationRGB.g <= 0.5)),select((1.0 - 2.0 * (1.0 - destinationRGB.b) * (1.0 - sourceRGB.b)), (2.0 * sourceRGB.b * destinationRGB.b), (destinationRGB.b <= 0.5))), blendedColor.a);
  }

  // Soft Light
  else if (blendMode == 12) {
    blendedColor = vec4<f32>(vec3<f32>(select((select((destinationRGB.r + (2.0 * sourceRGB.r - 1.0) * (sqrt(destinationRGB.r) - destinationRGB.r)), (destinationRGB.r + (2.0 * sourceRGB.r - 1.0) * (4.0 * destinationRGB.r * (4.0 * destinationRGB.r + 1.0) * (destinationRGB.r - 1.0) + 7.0 * destinationRGB.r)), ((sourceRGB.r > 0.5) && (destinationRGB.r <= 0.25)))), (destinationRGB.r - (1.0 - 2.0 * sourceRGB.r) * destinationRGB.r * (1.0 - destinationRGB.r)), (sourceRGB.r <= 0.5)),select((select((destinationRGB.g + (2.0 * sourceRGB.g - 1.0) * (sqrt(destinationRGB.g) - destinationRGB.g)), (destinationRGB.g + (2.0 * sourceRGB.g - 1.0) * (4.0 * destinationRGB.g * (4.0 * destinationRGB.g + 1.0) * (destinationRGB.g - 1.0) + 7.0 * destinationRGB.g)), ((sourceRGB.g > 0.5) && (destinationRGB.g <= 0.25)))), (destinationRGB.g - (1.0 - 2.0 * sourceRGB.g) * destinationRGB.g * (1.0 - destinationRGB.g)), (sourceRGB.g <= 0.5)),select((select((destinationRGB.b + (2.0 * sourceRGB.b - 1.0) * (sqrt(destinationRGB.b) - destinationRGB.b)), (destinationRGB.b + (2.0 * sourceRGB.b - 1.0) * (4.0 * destinationRGB.b * (4.0 * destinationRGB.b + 1.0) * (destinationRGB.b - 1.0) + 7.0 * destinationRGB.b)), ((sourceRGB.b > 0.5) && (destinationRGB.b <= 0.25)))), (destinationRGB.b - (1.0 - 2.0 * sourceRGB.b) * destinationRGB.b * (1.0 - destinationRGB.b)), (sourceRGB.b <= 0.5))), blendedColor.a);
  }

  // Hard Light
  else if (blendMode == 13) {
    blendedColor = vec4<f32>(vec3<f32>(select((1.0 - 2.0 * (1.0 - sourceRGB.r) * (1.0 - destinationRGB.r)), (2.0 * sourceRGB.r * destinationRGB.r), (sourceRGB.r <= 0.5)),select((1.0 - 2.0 * (1.0 - sourceRGB.g) * (1.0 - destinationRGB.g)), (2.0 * sourceRGB.g * destinationRGB.g), (sourceRGB.g <= 0.5)),select((1.0 - 2.0 * (1.0 - sourceRGB.b) * (1.0 - destinationRGB.b)), (2.0 * sourceRGB.b * destinationRGB.b), (sourceRGB.b <= 0.5))), blendedColor.a);
  }

  // Vivid Light
  else if (blendMode == 14) {
    blendedColor = vec4<f32>(vec3<f32>(select((destinationRGB.r / (2.0 * (1.0 - sourceRGB.r) + (0.0001))), (1.0 - (1.0 - destinationRGB.r) / (2.0 * sourceRGB.r + (0.0001))), (sourceRGB.r <= 0.5)),select((destinationRGB.g / (2.0 * (1.0 - sourceRGB.g) + (0.0001))), (1.0 - (1.0 - destinationRGB.g) / (2.0 * sourceRGB.g + (0.0001))), (sourceRGB.g <= 0.5)),select((destinationRGB.b / (2.0 * (1.0 - sourceRGB.b) + (0.0001))), (1.0 - (1.0 - destinationRGB.b) / (2.0 * sourceRGB.b + (0.0001))), (sourceRGB.b <= 0.5))), blendedColor.a);
  }


  // Linear Light
  else if (blendMode == 15) {
    blendedColor = vec4<f32>(2.0 * sourceRGB + destinationRGB - vec3<f32>(1.0), blendedColor.a);
  }

  // Pin Light
  else if (blendMode == 16) {
    blendedColor = vec4<f32>(vec3<f32>(select(min(destinationRGB.r, 2.0 * sourceRGB.r), max(destinationRGB.r, 2.0 * (sourceRGB.r - 0.5)), (sourceRGB.r > 0.5)),select(min(destinationRGB.g, 2.0 * sourceRGB.g), max(destinationRGB.g, 2.0 * (sourceRGB.g - 0.5)), (sourceRGB.g > 0.5)),select(min(destinationRGB.b, 2.0 * sourceRGB.b), max(destinationRGB.b, 2.0 * (sourceRGB.b - 0.5)), (sourceRGB.b > 0.5))), blendedColor.a);
  }

  // Difference
  else if (blendMode == 17) {
    blendedColor = vec4<f32>(abs(destinationRGB - sourceRGB), blendedColor.a);
  }

  // Exclusion
  else if (blendMode == 18) {
    blendedColor = vec4<f32>(destinationRGB + sourceRGB - 2.0 * destinationRGB * sourceRGB, blendedColor.a);
  }

  // Dissolve
  if (blendMode == 19) {
    // Create a random offset using gl_FragCoord
    var randomOffset: vec2<f32> = fract(sin(vec2<f32>((uv * uniforms.renderSize).x, (uv * uniforms.renderSize).y) * 12.9898) * 43758.5453);
    
    // Apply the random offset to the coordinates
    var noiseValue: f32 = simplex2DNoise((uv * uniforms.renderSize).xy + randomOffset);

    // Mix the colors based on the noise value
    blendedColor = vec4<f32>(mix(destinationRGB, sourceRGB, step(noiseValue, blendOpacity)), blendedColor.a);
  }
  
  // Darker Color
  else if (blendMode == 20) {
    var sourceBrightness: f32 = sourceRGB.r + sourceRGB.g + sourceRGB.b;
    var destinationBrightness: f32 = destinationRGB.r + destinationRGB.g + destinationRGB.b;
    if (sourceBrightness < destinationBrightness) {
      blendedColor = vec4<f32>(sourceRGB, blendedColor.a);
    }
    else {
      blendedColor = vec4<f32>(destinationRGB, blendedColor.a);
    }
  }
  
  // Lighter Color
  else if (blendMode == 21) {
    var sourceBrightness: f32 = sourceRGB.r + sourceRGB.g + sourceRGB.b;
    var destinationBrightness: f32 = destinationRGB.r + destinationRGB.g + destinationRGB.b;
    if (sourceBrightness > destinationBrightness) {
      blendedColor = vec4<f32>(sourceRGB, blendedColor.a);
    }
    else {
      blendedColor = vec4<f32>(destinationRGB, blendedColor.a);
    }
  }

  // Hard Mix
  else if (blendMode == 22) {
    blendedColor = vec4<f32>(vec3<f32>(select(1.0, 0.0, (select((select(min(sourceRGB.r / (1.0 - (2.0 * (destinationRGB.r - 0.5))), 1.0), destinationRGB.r, (destinationRGB.r == 1.0))), (select(max((1.0 - ((1.0 - sourceRGB.r) / (2.0 * destinationRGB.r))), 0.0), destinationRGB.r, (destinationRGB.r == 0.0))), (destinationRGB.r < 0.5))) < 0.5),select(1.0, 0.0, (select((select(min(sourceRGB.g / (1.0 - (2.0 * (destinationRGB.g - 0.5))), 1.0), destinationRGB.g, (destinationRGB.g == 1.0))), (select(max((1.0 - ((1.0 - sourceRGB.g) / (2.0 * destinationRGB.g))), 0.0), destinationRGB.g, (destinationRGB.g == 0.0))), (destinationRGB.g < 0.5))) < 0.5),select(1.0, 0.0, (select((select(min(sourceRGB.b / (1.0 - (2.0 * (destinationRGB.b - 0.5))), 1.0), destinationRGB.b, (destinationRGB.b == 1.0))), (select(max((1.0 - ((1.0 - sourceRGB.b) / (2.0 * destinationRGB.b))), 0.0), destinationRGB.b, (destinationRGB.b == 0.0))), (destinationRGB.b < 0.5))) < 0.5)), blendedColor.a);
  }
  
  // Divide
  else if (blendMode == 23) {
    blendedColor = vec4<f32>(destinationRGB / (sourceRGB + (0.0001)), blendedColor.a);
  }

  // Hue
  else if (blendMode == 24) {
    var sourceHSL: vec3<f32> = RGBToHSL(sourceRGB);
    var destinationHSL: vec3<f32> = RGBToHSL(destinationRGB);
    blendedColor = vec4<f32>(HSLToRGB(vec3<f32>(sourceHSL.x, destinationHSL.y, destinationHSL.z)), blendedColor.a);
  }

  // Saturation
  else if (blendMode == 25) {
    var sourceHSL: vec3<f32> = RGBToHSL(sourceRGB);
    var destinationHSL: vec3<f32> = RGBToHSL(destinationRGB);
    blendedColor = vec4<f32>(HSLToRGB(vec3<f32>(destinationHSL.x, sourceHSL.y, destinationHSL.z)), blendedColor.a);
  }

  // Color
  else if (blendMode == 26) {
    var sourceHSL: vec3<f32> = RGBToHSL(sourceRGB);
    var destinationHSL: vec3<f32> = RGBToHSL(destinationRGB);
    blendedColor = vec4<f32>(HSLToRGB(vec3<f32>(sourceHSL.x, sourceHSL.y, destinationHSL.z)), blendedColor.a);
  }

  // Luminosity
  else if (blendMode == 27) {
    var sourceHSL: vec3<f32> = RGBToHSL(destinationRGB); // using destinationRGB for the hue and saturation
    var blendHSL: vec3<f32> = RGBToHSL(sourceRGB); // using sourceRGB for the luminance
    blendedColor = vec4<f32>(HSLToRGB(vec3<f32>(sourceHSL.r, sourceHSL.g, blendHSL.b)), blendedColor.a); // Combining hue, saturation, and luminance
  }

  // Reflect
  else if (blendMode == 28) {
    blendedColor = vec4<f32>(vec3<f32>(select(min(destinationRGB.r * destinationRGB.r / (1.0 - sourceRGB.r), 1.0), sourceRGB.r, (sourceRGB.r == 1.0)),select(min(destinationRGB.g * destinationRGB.g / (1.0 - sourceRGB.g), 1.0), sourceRGB.g, (sourceRGB.g == 1.0)),select(min(destinationRGB.b * destinationRGB.b / (1.0 - sourceRGB.b), 1.0), sourceRGB.b, (sourceRGB.b == 1.0))), blendedColor.a);
  }

  // Glow
  else if (blendMode == 29) {
    blendedColor = vec4<f32>(vec3<f32>(select(min(sourceRGB.r * sourceRGB.r / (1.0 - destinationRGB.r), 1.0), destinationRGB.r, (destinationRGB.r == 1.0)),select(min(sourceRGB.g * sourceRGB.g / (1.0 - destinationRGB.g), 1.0), destinationRGB.g, (destinationRGB.g == 1.0)),select(min(sourceRGB.b * sourceRGB.b / (1.0 - destinationRGB.b), 1.0), destinationRGB.b, (destinationRGB.b == 1.0))), blendedColor.a);
  }

  // Phoenix
  else if (blendMode == 30) {
    blendedColor = vec4<f32>(vec3<f32>(min(sourceRGB.r, destinationRGB.r) - max(sourceRGB.r, destinationRGB.r) + 1.0,
                          min(sourceRGB.g, destinationRGB.g) - max(sourceRGB.g, destinationRGB.g) + 1.0,
                          min(sourceRGB.b, destinationRGB.b) - max(sourceRGB.b, destinationRGB.b) + 1.0), blendedColor.a);
  }

  // Average
  else if (blendMode == 31) {
    blendedColor = vec4<f32>((sourceRGB + destinationRGB) / 2.0, blendedColor.a);
  }

  // Negation
  else if (blendMode == 32) {
    blendedColor = vec4<f32>(vec3<f32>(1.0 - abs(1.0 - sourceRGB.r - destinationRGB.r),
                          1.0 - abs(1.0 - sourceRGB.g - destinationRGB.g),
                          1.0 - abs(1.0 - sourceRGB.b - destinationRGB.b)), blendedColor.a);
  }

  // Copy Red
  else if (blendMode == 33) {
    blendedColor = vec4<f32>(vec3<f32>(sourceRGB.r, destinationRGB.g, destinationRGB.b), blendedColor.a);
  }

  // Copy Green
  else if (blendMode == 34) {
    blendedColor = vec4<f32>(vec3<f32>(destinationRGB.r, sourceRGB.g, destinationRGB.b), blendedColor.a);
  }

  // Copy Blue
  else if (blendMode == 35) {
    blendedColor = vec4<f32>(vec3<f32>(destinationRGB.r, destinationRGB.g, sourceRGB.b), blendedColor.a);
  }

  // Interpolation
  else if (blendMode == 36) {
    var baseCos: vec3<f32> = cos((3.1415926535897932384626433832795) * destinationRGB);
    var blendCos: vec3<f32> = cos((3.1415926535897932384626433832795) * sourceRGB);
    blendedColor = vec4<f32>(0.5 - 0.25 * blendCos - 0.25 * baseCos, blendedColor.a);
  }

  // Interpolation 2X
  else if (blendMode == 37) { // Adjust the value according to the correct blend mode number
    var baseCos1: vec3<f32> = cos((3.1415926535897932384626433832795) * destinationRGB);
    var blendCos1: vec3<f32> = cos((3.1415926535897932384626433832795) * sourceRGB);
    var result1: vec3<f32> = 0.5 - 0.25 * blendCos1 - 0.25 * baseCos1;

    var baseCos2: vec3<f32> = cos((3.1415926535897932384626433832795) * result1);
    var blendCos2: vec3<f32> = cos((3.1415926535897932384626433832795) * result1);
    blendedColor = vec4<f32>(0.5 - 0.25 * blendCos2 - 0.25 * baseCos2, blendedColor.a);
  }

  // Gamma Light
  else if (blendMode == 38) {
    blendedColor = vec4<f32>(pow(sourceRGB, destinationRGB), blendedColor.a);
  }

  // Exclude Red
  else if (blendMode == 39) {
    blendedColor = vec4<f32>(vec3<f32>(destinationRGB.r, sourceRGB.g, sourceRGB.b), blendedColor.a);
  }

  // Exclude Green
  else if (blendMode == 40) {
    blendedColor = vec4<f32>(vec3<f32>(sourceRGB.r, destinationRGB.g, sourceRGB.b), blendedColor.a);
  }

  // Exclude Blue
  else if (blendMode == 41) {
    blendedColor = vec4<f32>(vec3<f32>(sourceRGB.r, sourceRGB.g, destinationRGB.b), blendedColor.a);
  }

  // Hard Overlay
  else if (blendMode == 42) {
    blendedColor = vec4<f32>(vec3<f32>(select((1.0 - (2.0 * (1.0 - sourceRGB.r) / (1.0 - destinationRGB.r + (0.0001)))), (2.0 * sourceRGB.r * destinationRGB.r), (sourceRGB.r <= 0.5)),select((1.0 - (2.0 * (1.0 - sourceRGB.g) / (1.0 - destinationRGB.g + (0.0001)))), (2.0 * sourceRGB.g * destinationRGB.g), (sourceRGB.g <= 0.5)),select((1.0 - (2.0 * (1.0 - sourceRGB.b) / (1.0 - destinationRGB.b + (0.0001)))), (2.0 * sourceRGB.b * destinationRGB.b), (sourceRGB.b <= 0.5))), blendedColor.a);
  }

  // Fog Lighten IFS Illusions (Bright)
  else if (blendMode == 43) {
    blendedColor = vec4<f32>(vec3<f32>(select(0.0, (select((sourceRGB.r - 1.0 / (destinationRGB.r * 1.0 / sourceRGB.r) + pow(1.0 / sourceRGB.r, 2.0)), (1.0 / (1.0 / sourceRGB.r * sourceRGB.r) - 1.0 / (destinationRGB.r * 1.0 / sourceRGB.r)), (sourceRGB.r < 0.5))), (sourceRGB.r != 0.0 && destinationRGB.r != 0.0)),select(0.0, (select((sourceRGB.g - 1.0 / (destinationRGB.g * 1.0 / sourceRGB.g) + pow(1.0 / sourceRGB.g, 2.0)), (1.0 / (1.0 / sourceRGB.g * sourceRGB.g) - 1.0 / (destinationRGB.g * 1.0 / sourceRGB.g)), (sourceRGB.g < 0.5))), (sourceRGB.g != 0.0 && destinationRGB.g != 0.0)),select(0.0, (select((sourceRGB.b - 1.0 / (destinationRGB.b * 1.0 / sourceRGB.b) + pow(1.0 / sourceRGB.b, 2.0)), (1.0 / (1.0 / sourceRGB.b * sourceRGB.b) - 1.0 / (destinationRGB.b * 1.0 / sourceRGB.b)), (sourceRGB.b < 0.5))), (sourceRGB.b != 0.0 && destinationRGB.b != 0.0))), blendedColor.a);
  }
  
  // Fog Darken IFS Illusions (Dark)
  else if (blendMode == 44) {
    blendedColor = vec4<f32>(vec3<f32>(select(0.0, (select((sourceRGB.r * destinationRGB.r + sourceRGB.r - pow(sourceRGB.r, 2.0)), ((1.0 / sourceRGB.r) * sourceRGB.r + sourceRGB.r * destinationRGB.r), (sourceRGB.r < 0.5))), (sourceRGB.r != 0.0)),select(0.0, (select((sourceRGB.g * destinationRGB.g + sourceRGB.g - pow(sourceRGB.g, 2.0)), ((1.0 / sourceRGB.g) * sourceRGB.g + sourceRGB.g * destinationRGB.g), (sourceRGB.g < 0.5))), (sourceRGB.g != 0.0)),select(0.0, (select((sourceRGB.b * destinationRGB.b + sourceRGB.b - pow(sourceRGB.b, 2.0)), ((1.0 / sourceRGB.b) * sourceRGB.b + sourceRGB.b * destinationRGB.b), (sourceRGB.b < 0.5))), (sourceRGB.b != 0.0))), blendedColor.a);
  }      

  // Super Light
  else if (blendMode == 45) {
    blendedColor = vec4<f32>(vec3<f32>(select((pow(max(pow(destinationRGB.r, 2.875) + pow(2.0 * sourceRGB.r - 1.0, 2.875), 0.0001), 1.0 / 2.875)), (1.0 / pow(max(pow(1.0 / destinationRGB.r, 2.875) + pow(1.0 / (2.0 * sourceRGB.r), 2.875), 0.0001), 1.0 / 2.875)), (sourceRGB.r < 0.5)),select((pow(max(pow(destinationRGB.g, 2.875) + pow(2.0 * sourceRGB.g - 1.0, 2.875), 0.0001), 1.0 / 2.875)), (1.0 / pow(max(pow(1.0 / destinationRGB.g, 2.875) + pow(1.0 / (2.0 * sourceRGB.g), 2.875), 0.0001), 1.0 / 2.875)), (sourceRGB.g < 0.5)),select((pow(max(pow(destinationRGB.b, 2.875) + pow(2.0 * sourceRGB.b - 1.0, 2.875), 0.0001), 1.0 / 2.875)), (1.0 / pow(max(pow(1.0 / destinationRGB.b, 2.875) + pow(1.0 / (2.0 * sourceRGB.b), 2.875), 0.0001), 1.0 / 2.875)), (sourceRGB.b < 0.5))), blendedColor.a);
  }

  // Modulo Shift
  else if (blendMode == 46) { // Assuming 49 is the blend mode for cfModuloShift
    blendedColor = vec4<f32>(vec3<f32>(
      ((((destinationRGB.r + sourceRGB.r)) - (1.0) * floor(((destinationRGB.r + sourceRGB.r)) / (1.0)))),
      ((((destinationRGB.g + sourceRGB.g)) - (1.0) * floor(((destinationRGB.g + sourceRGB.g)) / (1.0)))),
      ((((destinationRGB.b + sourceRGB.b)) - (1.0) * floor(((destinationRGB.b + sourceRGB.b)) / (1.0))))
    ), blendedColor.a);
  
    if (sourceRGB.r == 1.0 && destinationRGB.r == 0.0) { blendedColor.r = 0.0; }
    if (sourceRGB.g == 1.0 && destinationRGB.g == 0.0) { blendedColor.g = 0.0; }
    if (sourceRGB.b == 1.0 && destinationRGB.b == 0.0) { blendedColor.b = 0.0; }
  }

  // Divisive Modulo
  else if (blendMode == 47) {
    blendedColor = vec4<f32>(vec3<f32>(select((((destinationRGB.r / 0.0000001) - (1.0) * floor((destinationRGB.r / 0.0000001) / (1.0)))), (((destinationRGB.r / sourceRGB.r) - (1.0) * floor((destinationRGB.r / sourceRGB.r) / (1.0)))), (sourceRGB.r != 0.0)),select((((destinationRGB.g / 0.0000001) - (1.0) * floor((destinationRGB.g / 0.0000001) / (1.0)))), (((destinationRGB.g / sourceRGB.g) - (1.0) * floor((destinationRGB.g / sourceRGB.g) / (1.0)))), (sourceRGB.g != 0.0)),select((((destinationRGB.b / 0.0000001) - (1.0) * floor((destinationRGB.b / 0.0000001) / (1.0)))), (((destinationRGB.b / sourceRGB.b) - (1.0) * floor((destinationRGB.b / sourceRGB.b) / (1.0)))), (sourceRGB.b != 0.0))), blendedColor.a);
  }
  
  // Divisive Modulo - Continuous
  else if (blendMode == 48) {
    blendedColor = vec4<f32>(vec3<f32>(select((((destinationRGB.r / 0.0000001) - (1.0) * floor((destinationRGB.r / 0.0000001) / (1.0)))), (select(1.0 - (((destinationRGB.r / sourceRGB.r) - (1.0) * floor((destinationRGB.r / sourceRGB.r) / (1.0)))), (((destinationRGB.r / sourceRGB.r) - (1.0) * floor((destinationRGB.r / sourceRGB.r) / (1.0)))), (((ceil(destinationRGB.r / sourceRGB.r)) - (2.0) * floor((ceil(destinationRGB.r / sourceRGB.r)) / (2.0)))) != 0.0)), (sourceRGB.r != 0.0)),select((((destinationRGB.g / 0.0000001) - (1.0) * floor((destinationRGB.g / 0.0000001) / (1.0)))), (select(1.0 - (((destinationRGB.g / sourceRGB.g) - (1.0) * floor((destinationRGB.g / sourceRGB.g) / (1.0)))), (((destinationRGB.g / sourceRGB.g) - (1.0) * floor((destinationRGB.g / sourceRGB.g) / (1.0)))), (((ceil(destinationRGB.g / sourceRGB.g)) - (2.0) * floor((ceil(destinationRGB.g / sourceRGB.g)) / (2.0)))) != 0.0)), (sourceRGB.g != 0.0)),select((((destinationRGB.b / 0.0000001) - (1.0) * floor((destinationRGB.b / 0.0000001) / (1.0)))), (select(1.0 - (((destinationRGB.b / sourceRGB.b) - (1.0) * floor((destinationRGB.b / sourceRGB.b) / (1.0)))), (((destinationRGB.b / sourceRGB.b) - (1.0) * floor((destinationRGB.b / sourceRGB.b) / (1.0)))), (((ceil(destinationRGB.b / sourceRGB.b)) - (2.0) * floor((ceil(destinationRGB.b / sourceRGB.b)) / (2.0)))) != 0.0)), (sourceRGB.b != 0.0))), blendedColor.a);
  }
  
  // Modulo
  else if (blendMode == 49) {
    blendedColor = vec4<f32>(vec3<f32>(select(destinationRGB.r, (((destinationRGB.r) - (sourceRGB.r) * floor((destinationRGB.r) / (sourceRGB.r)))), (sourceRGB.r != 0.0)),select(destinationRGB.g, (((destinationRGB.g) - (sourceRGB.g) * floor((destinationRGB.g) / (sourceRGB.g)))), (sourceRGB.g != 0.0)),select(destinationRGB.b, (((destinationRGB.b) - (sourceRGB.b) * floor((destinationRGB.b) / (sourceRGB.b)))), (sourceRGB.b != 0.0))), blendedColor.a);
  }
  

  // Modulo - Continuous
  else if (blendMode == 50) {
    blendedColor = vec4<f32>(vec3<f32>(select((select(1.0 - (((destinationRGB.r) - (sourceRGB.r) * floor((destinationRGB.r) / (sourceRGB.r)))), (((destinationRGB.r) - (sourceRGB.r) * floor((destinationRGB.r) / (sourceRGB.r)))), (((ceil(destinationRGB.r / sourceRGB.r)) - (2.0) * floor((ceil(destinationRGB.r / sourceRGB.r)) / (2.0)))) != 0.0)) * sourceRGB.r, 0.0, (sourceRGB.r == 0.0)),select((select(1.0 - (((destinationRGB.g) - (sourceRGB.g) * floor((destinationRGB.g) / (sourceRGB.g)))), (((destinationRGB.g) - (sourceRGB.g) * floor((destinationRGB.g) / (sourceRGB.g)))), (((ceil(destinationRGB.g / sourceRGB.g)) - (2.0) * floor((ceil(destinationRGB.g / sourceRGB.g)) / (2.0)))) != 0.0)) * sourceRGB.g, 0.0, (sourceRGB.g == 0.0)),select((select(1.0 - (((destinationRGB.b) - (sourceRGB.b) * floor((destinationRGB.b) / (sourceRGB.b)))), (((destinationRGB.b) - (sourceRGB.b) * floor((destinationRGB.b) / (sourceRGB.b)))), (((ceil(destinationRGB.b / sourceRGB.b)) - (2.0) * floor((ceil(destinationRGB.b / sourceRGB.b)) / (2.0)))) != 0.0)) * sourceRGB.b, 0.0, (sourceRGB.b == 0.0))), blendedColor.a);
  }

  // Additive Subtractive
  else if (blendMode == 51) {
    blendedColor = vec4<f32>(vec3<f32>(
      clamp(abs(sqrt(destinationRGB.r) - sqrt(sourceRGB.r)), 0.0, 1.0),
      clamp(abs(sqrt(destinationRGB.g) - sqrt(sourceRGB.g)), 0.0, 1.0),
      clamp(abs(sqrt(destinationRGB.b) - sqrt(sourceRGB.b)), 0.0, 1.0)
    ), blendedColor.a);
  }

  // Arc Tangent
  else if (blendMode == 52) {
    blendedColor = vec4<f32>(vec3<f32>(select((2.0 * atan(sourceRGB.r / destinationRGB.r) / 3.14159265), (select(1.0, 0.0, sourceRGB.r == 0.0)), (destinationRGB.r == 0.0)),select((2.0 * atan(sourceRGB.g / destinationRGB.g) / 3.14159265), (select(1.0, 0.0, sourceRGB.g == 0.0)), (destinationRGB.g == 0.0)),select((2.0 * atan(sourceRGB.b / destinationRGB.b) / 3.14159265), (select(1.0, 0.0, sourceRGB.b == 0.0)), (destinationRGB.b == 0.0))), blendedColor.a);
  }

  // Gamma Dark
  else if (blendMode == 53) { // Assuming the blend mode value for "Gamma Dark"
    blendedColor = vec4<f32>(vec3<f32>(select(pow(destinationRGB.r, 1.0 / sourceRGB.r), 0.0, (sourceRGB.r == 0.0)),select(pow(destinationRGB.g, 1.0 / sourceRGB.g), 0.0, (sourceRGB.g == 0.0)),select(pow(destinationRGB.b, 1.0 / sourceRGB.b), 0.0, (sourceRGB.b == 0.0))), blendedColor.a);
  }

  // Shade
  else if (blendMode == 54) { // Assuming the blend mode value for "Shade"
    blendedColor = vec4<f32>(vec3<f32>(
      1.0 / ((1.0 / destinationRGB.r * sourceRGB.r) + sqrt(1.0 / sourceRGB.r)),
      1.0 / ((1.0 / destinationRGB.g * sourceRGB.g) + sqrt(1.0 / sourceRGB.g)),
      1.0 / ((1.0 / destinationRGB.b * sourceRGB.b) + sqrt(1.0 / sourceRGB.b))
    ), blendedColor.a);
  }

  // Gamma Illumination
  else if (blendMode == 55) { 
    blendedColor = vec4<f32>(vec3<f32>(
      1.0 / pow(1.0 / destinationRGB.r, 1.0 / (1.0 / sourceRGB.r)),
      1.0 / pow(1.0 / destinationRGB.g, 1.0 / (1.0 / sourceRGB.g)),
      1.0 / pow(1.0 / destinationRGB.b, 1.0 / (1.0 / sourceRGB.b))
    ), blendedColor.a);
  }

  // Penumbra
  else if (blendMode == 56) { 
    blendedColor = vec4<f32>(vec3<f32>(select(select(select(1.0 / clamp(1.0 / destinationRGB.r, 0.0, 1.0) / sourceRGB.r / 2.0, 0.0, (sourceRGB.r == 0.0)), (min(1.0, destinationRGB.r / (1.0 - sourceRGB.r)) / 2.0), (destinationRGB.r + sourceRGB.r < 1.0)), 1.0, (destinationRGB.r == 1.0)),select(select(select(1.0 / clamp(1.0 / destinationRGB.g, 0.0, 1.0) / sourceRGB.g / 2.0, 0.0, (sourceRGB.g == 0.0)), (min(1.0, destinationRGB.g / (1.0 - sourceRGB.g)) / 2.0), (destinationRGB.g + sourceRGB.g < 1.0)), 1.0, (destinationRGB.g == 1.0)),select(select(select(1.0 / clamp(1.0 / destinationRGB.b, 0.0, 1.0) / sourceRGB.b / 2.0, 0.0, (sourceRGB.b == 0.0)), (min(1.0, destinationRGB.b / (1.0 - sourceRGB.b)) / 2.0), (destinationRGB.b + sourceRGB.b < 1.0)), 1.0, (destinationRGB.b == 1.0))), blendedColor.a);
  }

  // Parallel
  else if (blendMode == 57) { 
    blendedColor = vec4<f32>(vec3<f32>(select(clamp(2.0 / (1.0 / destinationRGB.r + 1.0 / sourceRGB.r), 0.0, 1.0), 0.0, (sourceRGB.r == 0.0 || destinationRGB.r == 0.0)),select(clamp(2.0 / (1.0 / destinationRGB.g + 1.0 / sourceRGB.g), 0.0, 1.0), 0.0, (sourceRGB.g == 0.0 || destinationRGB.g == 0.0)),select(clamp(2.0 / (1.0 / destinationRGB.b + 1.0 / sourceRGB.b), 0.0, 1.0), 0.0, (sourceRGB.b == 0.0 || destinationRGB.b == 0.0))), blendedColor.a);
  }

  // Color Erase
  else if (blendMode == 58) { 
    blendedColor = vec4<f32>(vec3<f32>(select(select(max(0.0, min(1.0, destinationRGB.r - sourceRGB.r)), destinationRGB.r, (sourceRGB.r == 1.0)), 0.0, (sourceRGB.r == 0.0)),select(select(max(0.0, min(1.0, destinationRGB.g - sourceRGB.g)), destinationRGB.g, (sourceRGB.g == 1.0)), 0.0, (sourceRGB.g == 0.0)),select(select(max(0.0, min(1.0, destinationRGB.b - sourceRGB.b)), destinationRGB.b, (sourceRGB.b == 1.0)), 0.0, (sourceRGB.b == 0.0))), blendedColor.a);
  }

  // Behind
  else if (blendMode == 59) {
    blendedColor = vec4<f32>(destinationRGB, blendedColor.a);
  }

  if (blendMode != 19 && blendMode != 59) { // Not Dissolve or Behind, which handle alpha differently
    blendedColor = vec4<f32>(mix(sourceRGB, blendedColor.rgb, blendOpacity), blendedColor.a);
  }
  else if (blendMode == 59) { // Behind
    blendedColor = vec4<f32>(mix(destinationRGB, blendedColor.rgb, blendOpacity), blendedColor.a);
  }

  // Set alpha
  blendedColor.a = mix(sourceA, destinationA, blendOpacity);

  return blendedColor;
}

@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
  var outputColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 1.0);
  // Get colors from both textures
  var baseColor: vec4<f32> = textureSampleLevel(baseTexture, baseTextureSampler, input.uv.xy, 0.0);
  var layerColor: vec4<f32> = textureSampleLevel(layerTexture, layerTextureSampler, input.uv.xy, 0.0);
  
  var blendedColor: vec4<f32>;

  if (uniforms.blendModeProgress <= 0.0) {
    // Only use blend mode A
    blendedColor = blend(layerColor, baseColor, uniforms.blendModeA, 1.0, input.uv);
  } 
  else if (uniforms.blendModeProgress >= 1.0) {
    // Only use blend mode B
    blendedColor = blend(layerColor, baseColor, uniforms.blendModeB, 1.0, input.uv);
  } 
  else {
    // Mix between the two blend modes using the phase
    var blendedColorA: vec4<f32> = blend(layerColor, baseColor, uniforms.blendModeA, 1.0, input.uv);
    var blendedColorB: vec4<f32> = blend(layerColor, baseColor, uniforms.blendModeB, 1.0, input.uv);
    blendedColor = mix(blendedColorA, blendedColorB, uniforms.blendModeProgress);
  }

  // Blend between the base and the blended color using the layer's alpha and opacity
  outputColor = vec4<f32>(mix(baseColor.rgb, blendedColor.rgb, layerColor.a * uniforms.opacity), outputColor.a);

  // Calculate the final alpha value
  if ((uniforms.forceAlpha != 0.0)) {
    outputColor.a = mix(baseColor.a, layerColor.a, uniforms.opacity);
  } 
  else {
    outputColor.a = 1.0;
  }

  return vec4<f32>(outputColor.rgb, outputColor.a * uniforms.layerOpacity);
}
