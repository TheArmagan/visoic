// Generated by ISFToWGSLCompiler
// Original: Composite shader with opacity blending and blend modes
// Credit: Simple ISF composite with blend modes


struct VertexOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) uv: vec2<f32>,
}

struct Uniforms {
  time: f32,
  timeDelta: f32,
  renderSize: vec2<f32>,
  passIndex: f32,
  frameIndex: f32,
  layerOpacity: f32,
  speed: f32,
  date: vec4<f32>,
  opacity: f32,
  forceAlpha: f32,
  blendModeA: f32,
  blendModeB: f32,
  blendModeProgress: f32,
  BUILTIN_SPEED: f32,
  _pad_72: f32,
}

@group(0) @binding(0) var<uniform> uniforms: Uniforms;

@group(1) @binding(0) var tex_baseTexture: texture_2d<f32>;
@group(1) @binding(1) var samp_baseTexture: sampler;
@group(1) @binding(2) var tex_layerTexture: texture_2d<f32>;
@group(1) @binding(3) var samp_layerTexture: sampler;

// Helper functions
fn fract_f32(x: f32) -> f32 { return x - floor(x); }
fn fract_vec2(v: vec2<f32>) -> vec2<f32> { return v - floor(v); }
fn fract_vec3(v: vec3<f32>) -> vec3<f32> { return v - floor(v); }
fn fract_vec4(v: vec4<f32>) -> vec4<f32> { return v - floor(v); }

fn glsl_mod(x: f32, y: f32) -> f32 { return x - y * floor(x / y); }
fn glsl_mod_vec2(x: vec2<f32>, y: f32) -> vec2<f32> { return x - y * floor(x / y); }
fn glsl_mod_vec3(x: vec3<f32>, y: f32) -> vec3<f32> { return x - y * floor(x / y); }
fn glsl_mod_vec4(x: vec4<f32>, y: f32) -> vec4<f32> { return x - y * floor(x / y); }
fn glsl_mod_vec2_vec2(x: vec2<f32>, y: vec2<f32>) -> vec2<f32> { return x - y * floor(x / y); }
fn glsl_mod_vec3_vec3(x: vec3<f32>, y: vec3<f32>) -> vec3<f32> { return x - y * floor(x / y); }
fn glsl_mod_vec4_vec4(x: vec4<f32>, y: vec4<f32>) -> vec4<f32> { return x - y * floor(x / y); }

fn lessThan_vec2(a: vec2<f32>, b: vec2<f32>) -> vec2<bool> { return vec2<bool>(a.x < b.x, a.y < b.y); }
fn lessThan_vec3(a: vec3<f32>, b: vec3<f32>) -> vec3<bool> { return vec3<bool>(a.x < b.x, a.y < b.y, a.z < b.z); }
fn greaterThan_vec2(a: vec2<f32>, b: vec2<f32>) -> vec2<bool> { return vec2<bool>(a.x > b.x, a.y > b.y); }
fn greaterThan_vec3(a: vec3<f32>, b: vec3<f32>) -> vec3<bool> { return vec3<bool>(a.x > b.x, a.y > b.y, a.z > b.z); }




fn HueToRGB(f1: f32, f2: f32, hue: f32) -> f32 {
        var _local_hue: f32 = hue;

  if (_local_hue < 0.0) {
    _local_hue += 1.0;
  }
  else if (_local_hue > 1.0) {
    _local_hue -= 1.0;
  }
  var res: f32;
  if ((6.0 * _local_hue) < 1.0) {
    res = f1 + (f2 - f1) * 6.0 * _local_hue;
  }
  else if ((2.0 * _local_hue) < 1.0) {
    res = f2;
  }
  else if ((3.0 * _local_hue) < 2.0) {
    res = f1 + (f2 - f1) * ((2.0 / 3.0) - _local_hue) * 6.0;
  }
  else {
    res = f1;
  }

  return res;
}

fn HSLToRGB(hsl: vec3<f32>) -> vec3<f32> {
  var rgb: vec3<f32>;
  
  if (hsl.y == 0.0) {
    rgb = vec3<f32>(hsl.z); 
  }
  else {
    var f2: f32;
    
    if (hsl.z < 0.5) {
      f2 = hsl.z * (1.0 + hsl.y);
    }
    else {
      f2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);
    }
      
    var f1: f32 = 2.0 * hsl.z - f2;
    
    rgb.r = HueToRGB(f1, f2, hsl.x + (1.0/3.0));
    rgb.g = HueToRGB(f1, f2, hsl.x);
    rgb.b= HueToRGB(f1, f2, hsl.x - (1.0/3.0));
  }
  
  return rgb;
}

fn RGBToHSL(color: vec3<f32>) -> vec3<f32> {
  var hsl: vec3<f32>;

  var fmin: f32 = min(min(color.r, color.g), color.b);  
  var fmax: f32 = max(max(color.r, color.g), color.b);  
  var delta: f32 = fmax - fmin;                         

  hsl.z = (fmax + fmin) / 2.0; 

  
  if (delta == 0.0)	{
    hsl.x = 0.0;	
    hsl.y = 0.0;	
  }
  
  else {
    if (hsl.z < 0.5) {
      hsl.y = delta / (fmax + fmin); 
    }
    else {
      hsl.y = delta / (2.0 - fmax - fmin); 
    }
    
    var deltaR: f32 = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;
    var deltaG: f32 = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;
    var deltaB: f32 = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;

    if (color.r == fmax ) {
      hsl.x = deltaB - deltaG; 
    }
    else if (color.g == fmax) {
      hsl.x = (1.0 / 3.0) + deltaR - deltaB; 
    }
    else if (color.b == fmax) {
      hsl.x = (2.0 / 3.0) + deltaG - deltaR; 
    }
    if (hsl.x < 0.0) {
      hsl.x += 1.0; 
    }
    else if (hsl.x > 1.0) {
      hsl.x -= 1.0; 
    }
  }

  return hsl;
}

fn permute(x: vec3<f32>) -> vec3<f32> { 
  return glsl_mod_vec3(((x*34.0)+1.0)*x, 289.0); 
}

fn simplex2DNoise(v: vec2<f32>) -> f32 {
  const C: vec4<f32> = vec4<f32>(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
  var i: vec2<f32> = floor(v + dot(v, C.yy) );
  var x0: vec2<f32> = v - i + dot(i, C.xx);
  var i1: vec2<f32>;
  i1 =select(vec2<f32>(0.0, 1.0), vec2<f32>(1.0, 0.0), (x0.x > x0.y));
  var x12: vec4<f32> = x0.xyxy + C.xxzz;
  { let _sw = i1; x12 = vec4<f32>(x12.x - _sw.x, x12.y - _sw.y, x12.z, x12.w); }
  i = glsl_mod_vec2(i, 289.0);
  var p: vec3<f32> = permute(permute( i.y + vec3<f32>(0.0, i1.y, 1.0 )) + i.x + vec3<f32>(0.0, i1.x, 1.0 ));
  var m: vec3<f32> = max(0.5 - vec3<f32>(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), vec3<f32>(0.0));
  m = m*m ;
  m = m*m ;
  var x: vec3<f32> = 2.0 * fract(p * C.www) - 1.0;
  var h: vec3<f32> = abs(x) - 0.5;
  var ox: vec3<f32> = floor(x + 0.5);
  var a0: vec3<f32> = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
  var g: vec3<f32>;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  { let _sw = a0.yz * x12.xz + h.yz * x12.yw; g = vec3<f32>(g.x, _sw.x, _sw.y); }
  return 130.0 * dot(m, g);
}

fn blendMode0To19(sourceRGB: vec3<f32>, destinationRGB: vec3<f32>, blendMode: i32, blendOpacity: f32, xyPos: vec2<f32>) -> vec3<f32> {
        var _local_blendMode: i32 = blendMode;

    var result: vec3<f32> = vec3<f32>(0.0);
    
    if (_local_blendMode == 0) {
        result = sourceRGB;
    }
    
    else if (_local_blendMode == 1) {
        result = sourceRGB + destinationRGB;
    }
    
    else if (_local_blendMode == 2) {
        result = destinationRGB - sourceRGB;
    }
    
    else if (_local_blendMode == 3) {
        result = sourceRGB * destinationRGB;
    }
    
    else if (_local_blendMode == 4) {
        result = min(sourceRGB, destinationRGB);
    }
    
    else if (_local_blendMode == 5) {
        result = vec3<f32>(select((1.0 - ((1.0 - destinationRGB.r) / sourceRGB.r)), 0.0, (sourceRGB.r == 0.0)),select((1.0 - ((1.0 - destinationRGB.g) / sourceRGB.g)), 0.0, (sourceRGB.g == 0.0)),select((1.0 - ((1.0 - destinationRGB.b) / sourceRGB.b)), 0.0, (sourceRGB.b == 0.0))
        );
    }
    
    else if (_local_blendMode == 6) {
        result = sourceRGB + destinationRGB - 1.0;
        result = clamp(result, vec3<f32>(0.0), vec3<f32>(1.0));
    }
    
    else if (_local_blendMode == 7) {
        result = max(sourceRGB, destinationRGB);
    }
    
    else if (_local_blendMode == 8) {
        result = sourceRGB + destinationRGB - sourceRGB * destinationRGB;
    }
    
    else if (_local_blendMode == 9) {
        result = vec3<f32>(select(min(1.0, destinationRGB.r / (1.0 - sourceRGB.r)), 1.0, (sourceRGB.r == 1.0)),select(min(1.0, destinationRGB.g / (1.0 - sourceRGB.g)), 1.0, (sourceRGB.g == 1.0)),select(min(1.0, destinationRGB.b / (1.0 - sourceRGB.b)), 1.0, (sourceRGB.b == 1.0))
        );
    }  
    
    else if (_local_blendMode == 10) {
        result = sourceRGB + destinationRGB;
    }
    
    else if (_local_blendMode == 11) {
        result = vec3<f32>(select((1.0 - 2.0 * (1.0 - destinationRGB.r) * (1.0 - sourceRGB.r)), (2.0 * sourceRGB.r * destinationRGB.r), (destinationRGB.r <= 0.5)),select((1.0 - 2.0 * (1.0 - destinationRGB.g) * (1.0 - sourceRGB.g)), (2.0 * sourceRGB.g * destinationRGB.g), (destinationRGB.g <= 0.5)),select((1.0 - 2.0 * (1.0 - destinationRGB.b) * (1.0 - sourceRGB.b)), (2.0 * sourceRGB.b * destinationRGB.b), (destinationRGB.b <= 0.5))
        );
    }
    
    else if (_local_blendMode == 12) {
        result = vec3<f32>(select((select((destinationRGB.r + (2.0 * sourceRGB.r - 1.0) * (sqrt(destinationRGB.r) - destinationRGB.r)), (destinationRGB.r + (2.0 * sourceRGB.r - 1.0) * (4.0 * destinationRGB.r * (4.0 * destinationRGB.r + 1.0) * (destinationRGB.r - 1.0) + 7.0 * destinationRGB.r)), ((sourceRGB.r > 0.5) && (destinationRGB.r <= 0.25)))), (destinationRGB.r - (1.0 - 2.0 * sourceRGB.r) * destinationRGB.r * (1.0 - destinationRGB.r)), (sourceRGB.r <= 0.5)),select((select((destinationRGB.g + (2.0 * sourceRGB.g - 1.0) * (sqrt(destinationRGB.g) - destinationRGB.g)), (destinationRGB.g + (2.0 * sourceRGB.g - 1.0) * (4.0 * destinationRGB.g * (4.0 * destinationRGB.g + 1.0) * (destinationRGB.g - 1.0) + 7.0 * destinationRGB.g)), ((sourceRGB.g > 0.5) && (destinationRGB.g <= 0.25)))), (destinationRGB.g - (1.0 - 2.0 * sourceRGB.g) * destinationRGB.g * (1.0 - destinationRGB.g)), (sourceRGB.g <= 0.5)),select((select((destinationRGB.b + (2.0 * sourceRGB.b - 1.0) * (sqrt(destinationRGB.b) - destinationRGB.b)), (destinationRGB.b + (2.0 * sourceRGB.b - 1.0) * (4.0 * destinationRGB.b * (4.0 * destinationRGB.b + 1.0) * (destinationRGB.b - 1.0) + 7.0 * destinationRGB.b)), ((sourceRGB.b > 0.5) && (destinationRGB.b <= 0.25)))), (destinationRGB.b - (1.0 - 2.0 * sourceRGB.b) * destinationRGB.b * (1.0 - destinationRGB.b)), (sourceRGB.b <= 0.5))
        );
    }
    
    else if (_local_blendMode == 13) {
        result = vec3<f32>(select((1.0 - 2.0 * (1.0 - sourceRGB.r) * (1.0 - destinationRGB.r)), (2.0 * sourceRGB.r * destinationRGB.r), (sourceRGB.r <= 0.5)),select((1.0 - 2.0 * (1.0 - sourceRGB.g) * (1.0 - destinationRGB.g)), (2.0 * sourceRGB.g * destinationRGB.g), (sourceRGB.g <= 0.5)),select((1.0 - 2.0 * (1.0 - sourceRGB.b) * (1.0 - destinationRGB.b)), (2.0 * sourceRGB.b * destinationRGB.b), (sourceRGB.b <= 0.5))
        );
    }
    
    else if (_local_blendMode == 14) {
        result = vec3<f32>(select((destinationRGB.r / (2.0 * (1.0 - sourceRGB.r) + (0.0001))), (1.0 - (1.0 - destinationRGB.r) / (2.0 * sourceRGB.r + (0.0001))), (sourceRGB.r <= 0.5)),select((destinationRGB.g / (2.0 * (1.0 - sourceRGB.g) + (0.0001))), (1.0 - (1.0 - destinationRGB.g) / (2.0 * sourceRGB.g + (0.0001))), (sourceRGB.g <= 0.5)),select((destinationRGB.b / (2.0 * (1.0 - sourceRGB.b) + (0.0001))), (1.0 - (1.0 - destinationRGB.b) / (2.0 * sourceRGB.b + (0.0001))), (sourceRGB.b <= 0.5))
        );
    }
    
    else if (_local_blendMode == 15) {
        result = 2.0 * sourceRGB + destinationRGB - vec3<f32>(1.0);
    }
    
    else if (_local_blendMode == 16) {
        result = vec3<f32>(select(min(destinationRGB.r, 2.0 * sourceRGB.r), max(destinationRGB.r, 2.0 * (sourceRGB.r - 0.5)), (sourceRGB.r > 0.5)),select(min(destinationRGB.g, 2.0 * sourceRGB.g), max(destinationRGB.g, 2.0 * (sourceRGB.g - 0.5)), (sourceRGB.g > 0.5)),select(min(destinationRGB.b, 2.0 * sourceRGB.b), max(destinationRGB.b, 2.0 * (sourceRGB.b - 0.5)), (sourceRGB.b > 0.5))
        );
    }
    
    else if (_local_blendMode == 17) {
        result = abs(destinationRGB - sourceRGB);
    }
    
    else if (_local_blendMode == 18) {
        result = destinationRGB + sourceRGB - 2.0 * destinationRGB * sourceRGB;
    }
    
    else if (_local_blendMode == 19) {
        
        var randomOffset: vec2<f32> = fract(sin(xyPos * 12.9898) * 43758.5453);
        
        
        var noiseValue: f32 = simplex2DNoise(xyPos + randomOffset);

        
        result = mix(destinationRGB, sourceRGB, step(noiseValue, blendOpacity));
    }
    return result;
}

fn blendMode20To39(sourceRGB: vec3<f32>, destinationRGB: vec3<f32>, blendMode: i32) -> vec3<f32> {
        var _local_blendMode: i32 = blendMode;

    var result: vec3<f32> = vec3<f32>(0.0);
    
    if (_local_blendMode == 20) {
        var sourceBrightness: f32 = sourceRGB.r + sourceRGB.g + sourceRGB.b;
        var destinationBrightness: f32 = destinationRGB.r + destinationRGB.g + destinationRGB.b;
        if (sourceBrightness < destinationBrightness) {
        result = sourceRGB;
        }
        else {
        result = destinationRGB;
        }
    }
    
    else if (_local_blendMode == 21) {
        var sourceBrightness: f32 = sourceRGB.r + sourceRGB.g + sourceRGB.b;
        var destinationBrightness: f32 = destinationRGB.r + destinationRGB.g + destinationRGB.b;
        if (sourceBrightness > destinationBrightness) {
        result = sourceRGB;
        }
        else {
        result = destinationRGB;
        }
    }
    
    else if (_local_blendMode == 22) {
        result = vec3<f32>(select(1.0, 0.0, (select((select(min(sourceRGB.r / (1.0 - (2.0 * (destinationRGB.r - 0.5))), 1.0), destinationRGB.r, (destinationRGB.r == 1.0))), (select(max((1.0 - ((1.0 - sourceRGB.r) / (2.0 * destinationRGB.r))), 0.0), destinationRGB.r, (destinationRGB.r == 0.0))), (destinationRGB.r < 0.5))) < 0.5),select(1.0, 0.0, (select((select(min(sourceRGB.g / (1.0 - (2.0 * (destinationRGB.g - 0.5))), 1.0), destinationRGB.g, (destinationRGB.g == 1.0))), (select(max((1.0 - ((1.0 - sourceRGB.g) / (2.0 * destinationRGB.g))), 0.0), destinationRGB.g, (destinationRGB.g == 0.0))), (destinationRGB.g < 0.5))) < 0.5),select(1.0, 0.0, (select((select(min(sourceRGB.b / (1.0 - (2.0 * (destinationRGB.b - 0.5))), 1.0), destinationRGB.b, (destinationRGB.b == 1.0))), (select(max((1.0 - ((1.0 - sourceRGB.b) / (2.0 * destinationRGB.b))), 0.0), destinationRGB.b, (destinationRGB.b == 0.0))), (destinationRGB.b < 0.5))) < 0.5)
        );
    }
    
    else if (_local_blendMode == 23) {
        result = destinationRGB / (sourceRGB + (0.0001));
    }
    
    else if (_local_blendMode == 24) {
        var sourceHSL: vec3<f32> = RGBToHSL(sourceRGB);
        var destinationHSL: vec3<f32> = RGBToHSL(destinationRGB);
        result = HSLToRGB(vec3<f32>(sourceHSL.x, destinationHSL.y, destinationHSL.z));
    }
    
    else if (_local_blendMode == 25) {
        var sourceHSL: vec3<f32> = RGBToHSL(sourceRGB);
        var destinationHSL: vec3<f32> = RGBToHSL(destinationRGB);
        result = HSLToRGB(vec3<f32>(destinationHSL.x, sourceHSL.y, destinationHSL.z));
    }
    
    else if (_local_blendMode == 26) {
        var sourceHSL: vec3<f32> = RGBToHSL(sourceRGB);
        var destinationHSL: vec3<f32> = RGBToHSL(destinationRGB);
        result = HSLToRGB(vec3<f32>(sourceHSL.x, sourceHSL.y, destinationHSL.z));
    }
    
    else if (_local_blendMode == 27) {
        var sourceHSL: vec3<f32> = RGBToHSL(destinationRGB); 
        var blendHSL: vec3<f32> = RGBToHSL(sourceRGB); 
        result = HSLToRGB(vec3<f32>(sourceHSL.r, sourceHSL.g, blendHSL.b)); 
    }
    
    else if (_local_blendMode == 28) {
        result = vec3<f32>(select(min(destinationRGB.r * destinationRGB.r / (1.0 - sourceRGB.r), 1.0), sourceRGB.r, (sourceRGB.r == 1.0)),select(min(destinationRGB.g * destinationRGB.g / (1.0 - sourceRGB.g), 1.0), sourceRGB.g, (sourceRGB.g == 1.0)),select(min(destinationRGB.b * destinationRGB.b / (1.0 - sourceRGB.b), 1.0), sourceRGB.b, (sourceRGB.b == 1.0)));
    }
    
    else if (_local_blendMode == 29) {
        result = vec3<f32>(select(min(sourceRGB.r * sourceRGB.r / (1.0 - destinationRGB.r), 1.0), destinationRGB.r, (destinationRGB.r == 1.0)),select(min(sourceRGB.g * sourceRGB.g / (1.0 - destinationRGB.g), 1.0), destinationRGB.g, (destinationRGB.g == 1.0)),select(min(sourceRGB.b * sourceRGB.b / (1.0 - destinationRGB.b), 1.0), destinationRGB.b, (destinationRGB.b == 1.0)));
    }
    
    else if (_local_blendMode == 30) {
        result = vec3<f32>(min(sourceRGB.r, destinationRGB.r) - max(sourceRGB.r, destinationRGB.r) + 1.0,
                            min(sourceRGB.g, destinationRGB.g) - max(sourceRGB.g, destinationRGB.g) + 1.0,
                            min(sourceRGB.b, destinationRGB.b) - max(sourceRGB.b, destinationRGB.b) + 1.0);
    }
    
    else if (_local_blendMode == 31) {
        result = (sourceRGB + destinationRGB) / 2.0;
    }
    
    else if (_local_blendMode == 32) {
        result = vec3<f32>(1.0 - abs(1.0 - sourceRGB.r - destinationRGB.r),
                            1.0 - abs(1.0 - sourceRGB.g - destinationRGB.g),
                            1.0 - abs(1.0 - sourceRGB.b - destinationRGB.b));
    }
    
    else if (_local_blendMode == 33) {
        result = vec3<f32>(sourceRGB.r, destinationRGB.g, destinationRGB.b);
    }
    
    else if (_local_blendMode == 34) {
        result = vec3<f32>(destinationRGB.r, sourceRGB.g, destinationRGB.b);
    }
    
    else if (_local_blendMode == 35) {
        result = vec3<f32>(destinationRGB.r, destinationRGB.g, sourceRGB.b);
    }
    
    else if (_local_blendMode == 36) {
        var baseCos: vec3<f32> = cos((3.1415926535897932384626433832795) * destinationRGB);
        var blendCos: vec3<f32> = cos((3.1415926535897932384626433832795) * sourceRGB);
        result = 0.5 - 0.25 * blendCos - 0.25 * baseCos;
    }
    
    else if (_local_blendMode == 37) { 
        var baseCos1: vec3<f32> = cos((3.1415926535897932384626433832795) * destinationRGB);
        var blendCos1: vec3<f32> = cos((3.1415926535897932384626433832795) * sourceRGB);
        var result1: vec3<f32> = 0.5 - 0.25 * blendCos1 - 0.25 * baseCos1;

        var baseCos2: vec3<f32> = cos((3.1415926535897932384626433832795) * result1);
        var blendCos2: vec3<f32> = cos((3.1415926535897932384626433832795) * result1);
        result = 0.5 - 0.25 * blendCos2 - 0.25 * baseCos2;
    }
    
    else if (_local_blendMode == 38) {
        result = pow(sourceRGB, destinationRGB);
    }
    
    else if (_local_blendMode == 39) {
        result = vec3<f32>(destinationRGB.r, sourceRGB.g, sourceRGB.b);
    }
    return result;
}

fn blendMode40To59(sourceRGB: vec3<f32>, destinationRGB: vec3<f32>, blendMode: i32) -> vec3<f32> {
        var _local_blendMode: i32 = blendMode;

    var result: vec3<f32> = vec3<f32>(0.0);
    
    if (_local_blendMode == 40) {
        result = vec3<f32>(sourceRGB.r, destinationRGB.g, sourceRGB.b);
    }
    
    else if (_local_blendMode == 41) {
        result = vec3<f32>(sourceRGB.r, sourceRGB.g, destinationRGB.b);
    }
    
    else if (_local_blendMode == 42) {
        result = vec3<f32>(select((1.0 - (2.0 * (1.0 - sourceRGB.r) / (1.0 - destinationRGB.r + (0.0001)))), (2.0 * sourceRGB.r * destinationRGB.r), (sourceRGB.r <= 0.5)),select((1.0 - (2.0 * (1.0 - sourceRGB.g) / (1.0 - destinationRGB.g + (0.0001)))), (2.0 * sourceRGB.g * destinationRGB.g), (sourceRGB.g <= 0.5)),select((1.0 - (2.0 * (1.0 - sourceRGB.b) / (1.0 - destinationRGB.b + (0.0001)))), (2.0 * sourceRGB.b * destinationRGB.b), (sourceRGB.b <= 0.5))
        );
    }
    
    else if (_local_blendMode == 43) {
        result = vec3<f32>(select(0.0, (select((sourceRGB.r - 1.0 / (destinationRGB.r * 1.0 / sourceRGB.r) + pow(1.0 / sourceRGB.r, 2.0)), (1.0 / (1.0 / sourceRGB.r * sourceRGB.r) - 1.0 / (destinationRGB.r * 1.0 / sourceRGB.r)), (sourceRGB.r < 0.5))), (sourceRGB.r != 0.0 && destinationRGB.r != 0.0)),select(0.0, (select((sourceRGB.g - 1.0 / (destinationRGB.g * 1.0 / sourceRGB.g) + pow(1.0 / sourceRGB.g, 2.0)), (1.0 / (1.0 / sourceRGB.g * sourceRGB.g) - 1.0 / (destinationRGB.g * 1.0 / sourceRGB.g)), (sourceRGB.g < 0.5))), (sourceRGB.g != 0.0 && destinationRGB.g != 0.0)),select(0.0, (select((sourceRGB.b - 1.0 / (destinationRGB.b * 1.0 / sourceRGB.b) + pow(1.0 / sourceRGB.b, 2.0)), (1.0 / (1.0 / sourceRGB.b * sourceRGB.b) - 1.0 / (destinationRGB.b * 1.0 / sourceRGB.b)), (sourceRGB.b < 0.5))), (sourceRGB.b != 0.0 && destinationRGB.b != 0.0))
        );
    }
    
    else if (_local_blendMode == 44) {
        result = vec3<f32>(select(0.0, (select((sourceRGB.r * destinationRGB.r + sourceRGB.r - pow(sourceRGB.r, 2.0)), ((1.0 / sourceRGB.r) * sourceRGB.r + sourceRGB.r * destinationRGB.r), (sourceRGB.r < 0.5))), (sourceRGB.r != 0.0)),select(0.0, (select((sourceRGB.g * destinationRGB.g + sourceRGB.g - pow(sourceRGB.g, 2.0)), ((1.0 / sourceRGB.g) * sourceRGB.g + sourceRGB.g * destinationRGB.g), (sourceRGB.g < 0.5))), (sourceRGB.g != 0.0)),select(0.0, (select((sourceRGB.b * destinationRGB.b + sourceRGB.b - pow(sourceRGB.b, 2.0)), ((1.0 / sourceRGB.b) * sourceRGB.b + sourceRGB.b * destinationRGB.b), (sourceRGB.b < 0.5))), (sourceRGB.b != 0.0))
        );
    }      
    
    else if (_local_blendMode == 45) {
        result = vec3<f32>(select((pow(max(pow(destinationRGB.r, 2.875) + pow(2.0 * sourceRGB.r - 1.0, 2.875), 0.0001), 1.0 / 2.875)), (1.0 / pow(max(pow(1.0 / destinationRGB.r, 2.875) + pow(1.0 / (2.0 * sourceRGB.r), 2.875), 0.0001), 1.0 / 2.875)), (sourceRGB.r < 0.5)),select((pow(max(pow(destinationRGB.g, 2.875) + pow(2.0 * sourceRGB.g - 1.0, 2.875), 0.0001), 1.0 / 2.875)), (1.0 / pow(max(pow(1.0 / destinationRGB.g, 2.875) + pow(1.0 / (2.0 * sourceRGB.g), 2.875), 0.0001), 1.0 / 2.875)), (sourceRGB.g < 0.5)),select((pow(max(pow(destinationRGB.b, 2.875) + pow(2.0 * sourceRGB.b - 1.0, 2.875), 0.0001), 1.0 / 2.875)), (1.0 / pow(max(pow(1.0 / destinationRGB.b, 2.875) + pow(1.0 / (2.0 * sourceRGB.b), 2.875), 0.0001), 1.0 / 2.875)), (sourceRGB.b < 0.5))
        );
    }
    
    else if (_local_blendMode == 46) {
        result = vec3<f32>(
        glsl_mod((destinationRGB.r + sourceRGB.r), 1.0),
        glsl_mod((destinationRGB.g + sourceRGB.g), 1.0),
        glsl_mod((destinationRGB.b + sourceRGB.b), 1.0)
        );
    
        if (sourceRGB.r == 1.0 && destinationRGB.r == 0.0) { result.r = 0.0; }
        if (sourceRGB.g == 1.0 && destinationRGB.g == 0.0) { result.g = 0.0; }
        if (sourceRGB.b == 1.0 && destinationRGB.b == 0.0) { result.b = 0.0; }
    }
    
    else if (_local_blendMode == 47) {
        result = vec3<f32>(select(glsl_mod(destinationRGB.r / 0.0000001, 1.0), glsl_mod(destinationRGB.r / sourceRGB.r, 1.0), (sourceRGB.r != 0.0)),select(glsl_mod(destinationRGB.g / 0.0000001, 1.0), glsl_mod(destinationRGB.g / sourceRGB.g, 1.0), (sourceRGB.g != 0.0)),select(glsl_mod(destinationRGB.b / 0.0000001, 1.0), glsl_mod(destinationRGB.b / sourceRGB.b, 1.0), (sourceRGB.b != 0.0))
        );
    }
    
    else if (_local_blendMode == 48) {
        result = vec3<f32>(select(glsl_mod(destinationRGB.r / 0.0000001, 1.0), (select(1.0 - glsl_mod(destinationRGB.r / sourceRGB.r, 1.0), glsl_mod(destinationRGB.r / sourceRGB.r, 1.0), glsl_mod(ceil(destinationRGB.r / sourceRGB.r), 2.0) != 0.0)), (sourceRGB.r != 0.0)),select(glsl_mod(destinationRGB.g / 0.0000001, 1.0), (select(1.0 - glsl_mod(destinationRGB.g / sourceRGB.g, 1.0), glsl_mod(destinationRGB.g / sourceRGB.g, 1.0), glsl_mod(ceil(destinationRGB.g / sourceRGB.g), 2.0) != 0.0)), (sourceRGB.g != 0.0)),select(glsl_mod(destinationRGB.b / 0.0000001, 1.0), (select(1.0 - glsl_mod(destinationRGB.b / sourceRGB.b, 1.0), glsl_mod(destinationRGB.b / sourceRGB.b, 1.0), glsl_mod(ceil(destinationRGB.b / sourceRGB.b), 2.0) != 0.0)), (sourceRGB.b != 0.0))
        );
    }
    
    else if (_local_blendMode == 49) {
        result = vec3<f32>(select(destinationRGB.r, glsl_mod(destinationRGB.r, sourceRGB.r), (sourceRGB.r != 0.0)),select(destinationRGB.g, glsl_mod(destinationRGB.g, sourceRGB.g), (sourceRGB.g != 0.0)),select(destinationRGB.b, glsl_mod(destinationRGB.b, sourceRGB.b), (sourceRGB.b != 0.0))
        );
    }
    
    else if (_local_blendMode == 50) {
        result = vec3<f32>(select((select(1.0 - glsl_mod(destinationRGB.r, sourceRGB.r), glsl_mod(destinationRGB.r, sourceRGB.r), glsl_mod(ceil(destinationRGB.r / sourceRGB.r), 2.0) != 0.0)) * sourceRGB.r, 0.0, (sourceRGB.r == 0.0)),select((select(1.0 - glsl_mod(destinationRGB.g, sourceRGB.g), glsl_mod(destinationRGB.g, sourceRGB.g), glsl_mod(ceil(destinationRGB.g / sourceRGB.g), 2.0) != 0.0)) * sourceRGB.g, 0.0, (sourceRGB.g == 0.0)),select((select(1.0 - glsl_mod(destinationRGB.b, sourceRGB.b), glsl_mod(destinationRGB.b, sourceRGB.b), glsl_mod(ceil(destinationRGB.b / sourceRGB.b), 2.0) != 0.0)) * sourceRGB.b, 0.0, (sourceRGB.b == 0.0))
        );
    }
    
    else if (_local_blendMode == 51) {
        result = vec3<f32>(
        clamp(abs(sqrt(destinationRGB.r) - sqrt(sourceRGB.r)), 0.0, 1.0),
        clamp(abs(sqrt(destinationRGB.g) - sqrt(sourceRGB.g)), 0.0, 1.0),
        clamp(abs(sqrt(destinationRGB.b) - sqrt(sourceRGB.b)), 0.0, 1.0)
        );
    }
    
    else if (_local_blendMode == 52) {
        var res52: vec3<f32> = vec3<f32>(0.0);
        
        if (destinationRGB.r == 0.0) {
            if (sourceRGB.r == 0.0) { res52.r = 0.0; } else { res52.r = 1.0; }
        } else {
            res52.r = 2.0 * atan(sourceRGB.r / destinationRGB.r) / 3.14159265;
        }

        if (destinationRGB.g == 0.0) {
            if (sourceRGB.g == 0.0) { res52.g = 0.0; } else { res52.g = 1.0; }
        } else {
            res52.g = 2.0 * atan(sourceRGB.g / destinationRGB.g) / 3.14159265;
        }

        if (destinationRGB.b == 0.0) {
            if (sourceRGB.b == 0.0) { res52.b = 0.0; } else { res52.b = 1.0; }
        } else {
            res52.b = 2.0 * atan(sourceRGB.b / destinationRGB.b) / 3.14159265;
        }
        
        result = res52;
    }
    
    else if (_local_blendMode == 53) {
        result = vec3<f32>(select(pow(destinationRGB.r, 1.0 / sourceRGB.r), 0.0, (sourceRGB.r == 0.0)),select(pow(destinationRGB.g, 1.0 / sourceRGB.g), 0.0, (sourceRGB.g == 0.0)),select(pow(destinationRGB.b, 1.0 / sourceRGB.b), 0.0, (sourceRGB.b == 0.0))
        );
    }
    
    else if (_local_blendMode == 54) {
        result = vec3<f32>(
        1.0 / ((1.0 / destinationRGB.r * sourceRGB.r) + sqrt(1.0 / sourceRGB.r)),
        1.0 / ((1.0 / destinationRGB.g * sourceRGB.g) + sqrt(1.0 / sourceRGB.g)),
        1.0 / ((1.0 / destinationRGB.b * sourceRGB.b) + sqrt(1.0 / sourceRGB.b))
        );
    }
    
    else if (_local_blendMode == 55) { 
        result = vec3<f32>(
        1.0 / pow(1.0 / destinationRGB.r, 1.0 / (1.0 / sourceRGB.r)),
        1.0 / pow(1.0 / destinationRGB.g, 1.0 / (1.0 / sourceRGB.g)),
        1.0 / pow(1.0 / destinationRGB.b, 1.0 / (1.0 / sourceRGB.b))
        );
    }
    
    else if (_local_blendMode == 56) { 
        result = vec3<f32>(select(select(select(1.0 / clamp(1.0 / destinationRGB.r, 0.0, 1.0) / sourceRGB.r / 2.0, 0.0, (sourceRGB.r == 0.0)), (min(1.0, destinationRGB.r / (1.0 - sourceRGB.r)) / 2.0), (destinationRGB.r + sourceRGB.r < 1.0)), 1.0, (destinationRGB.r == 1.0)),select(select(select(1.0 / clamp(1.0 / destinationRGB.g, 0.0, 1.0) / sourceRGB.g / 2.0, 0.0, (sourceRGB.g == 0.0)), (min(1.0, destinationRGB.g / (1.0 - sourceRGB.g)) / 2.0), (destinationRGB.g + sourceRGB.g < 1.0)), 1.0, (destinationRGB.g == 1.0)),select(select(select(1.0 / clamp(1.0 / destinationRGB.b, 0.0, 1.0) / sourceRGB.b / 2.0, 0.0, (sourceRGB.b == 0.0)), (min(1.0, destinationRGB.b / (1.0 - sourceRGB.b)) / 2.0), (destinationRGB.b + sourceRGB.b < 1.0)), 1.0, (destinationRGB.b == 1.0))
        );
    }
    
    else if (_local_blendMode == 57) { 
        result = vec3<f32>(select(clamp(2.0 / (1.0 / destinationRGB.r + 1.0 / sourceRGB.r), 0.0, 1.0), 0.0, (sourceRGB.r == 0.0 || destinationRGB.r == 0.0)),select(clamp(2.0 / (1.0 / destinationRGB.g + 1.0 / sourceRGB.g), 0.0, 1.0), 0.0, (sourceRGB.g == 0.0 || destinationRGB.g == 0.0)),select(clamp(2.0 / (1.0 / destinationRGB.b + 1.0 / sourceRGB.b), 0.0, 1.0), 0.0, (sourceRGB.b == 0.0 || destinationRGB.b == 0.0))
        );
    }
    
    else if (_local_blendMode == 58) { 
        result = vec3<f32>(select(select(max(0.0, min(1.0, destinationRGB.r - sourceRGB.r)), destinationRGB.r, (sourceRGB.r == 1.0)), 0.0, (sourceRGB.r == 0.0)),select(select(max(0.0, min(1.0, destinationRGB.g - sourceRGB.g)), destinationRGB.g, (sourceRGB.g == 1.0)), 0.0, (sourceRGB.g == 0.0)),select(select(max(0.0, min(1.0, destinationRGB.b - sourceRGB.b)), destinationRGB.b, (sourceRGB.b == 1.0)), 0.0, (sourceRGB.b == 0.0))
        );
    }
    
    else if (_local_blendMode == 59) {
        result = destinationRGB;
    }
    return result;
}


fn blend(sourceColor: vec4<f32>, destinationColor: vec4<f32>, blendMode: i32, blendOpacity: f32, xyPos: vec2<f32>) -> vec4<f32> {
        var _local_blendMode: i32 = blendMode;

  var sourceRGB: vec3<f32> = sourceColor.rgb;
  var destinationRGB: vec3<f32> = destinationColor.rgb;
  
  var sourceA: f32 = sourceColor.a;
  var destinationA: f32 = destinationColor.a;

  var blendedRGB: vec3<f32>;
  
  
  if (_local_blendMode < 20) {
    blendedRGB = blendMode0To19(sourceRGB, destinationRGB, _local_blendMode, blendOpacity, xyPos);
  } else if (_local_blendMode < 40) {
    blendedRGB = blendMode20To39(sourceRGB, destinationRGB, _local_blendMode);
  } else {
    blendedRGB = blendMode40To59(sourceRGB, destinationRGB, _local_blendMode);
  }

  
  if (_local_blendMode != 19 && _local_blendMode != 59) { 
    blendedRGB = mix(sourceRGB, blendedRGB, blendOpacity);
  }
  else if (_local_blendMode == 59) { 
    blendedRGB = mix(destinationRGB, blendedRGB, blendOpacity);
  }
  

  
  var blendedAlpha: f32 = mix(sourceA, destinationA, blendOpacity);

  return vec4<f32>(blendedRGB, blendedAlpha);
}

@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
  var _isf_fragColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 1.0);
  
  var baseColor: vec4<f32> = textureSampleLevel(tex_baseTexture, samp_baseTexture, input.uv.xy, 0.0);
  var layerColor: vec4<f32> = textureSampleLevel(tex_layerTexture, samp_layerTexture, input.uv.xy, 0.0);
  
  var blendedColor: vec4<f32>;

  if (uniforms.blendModeProgress <= 0.0) {
    
    blendedColor = blend(layerColor, baseColor, i32(i32(uniforms.blendModeA)), 1.0, (input.uv * uniforms.renderSize).xy);
  }
  else if (uniforms.blendModeProgress >= 1.0) {
    
    blendedColor = blend(layerColor, baseColor, i32(i32(uniforms.blendModeB)), 1.0, (input.uv * uniforms.renderSize).xy);
  }
  else {
    
    var blendedColorA: vec4<f32> = blend(layerColor, baseColor, i32(i32(uniforms.blendModeA)), 1.0, (input.uv * uniforms.renderSize).xy);
    var blendedColorB: vec4<f32> = blend(layerColor, baseColor, i32(i32(uniforms.blendModeB)), 1.0, (input.uv * uniforms.renderSize).xy);
    blendedColor = mix(blendedColorA, blendedColorB, uniforms.blendModeProgress);
  }

  
  _isf_fragColor = vec4<f32>((mix(baseColor.rgb, blendedColor.rgb, layerColor.a * uniforms.opacity)), _isf_fragColor.w);

  
  if ((uniforms.forceAlpha != 0.0)) {
    _isf_fragColor.a = mix(baseColor.a, layerColor.a, uniforms.opacity);
  } 
  else {
    _isf_fragColor.a = 1.0;
  }

  return _isf_fragColor;
}